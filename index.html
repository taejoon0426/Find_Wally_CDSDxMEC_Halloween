<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Find Wally — Image Detection [CDSD x MEC]</title>
  <style>
    :root { --bg:#0b0b0b; --fg:#eaeaea; --muted:#9aa0a6; --accent:#ff4d4f; }
    * { box-sizing: border-box; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; background:var(--bg); color:var(--fg); }
    header { padding: 24px 20px; border-bottom: 1px solid #222; display:flex; align-items:center; gap:12px; }
    header h1 { font-size: 18px; margin:0; font-weight:700; letter-spacing:0.3px; }
    main { max-width: 980px; margin: 24px auto; padding: 0 20px 60px; display:grid; grid-template-columns: 1fr 1fr; gap: 24px; }
    .card { background:#111; border:1px solid #222; border-radius: 16px; padding: 16px; box-shadow: 0 10px 24px rgba(0,0,0,0.25); }
    .controls { display:flex; gap:10px; margin-top:12px; flex-wrap:wrap; }
    button { padding:10px 14px; border-radius: 10px; border:1px solid #333; background:#181818; color:var(--fg); cursor:pointer; font-weight:600; }
    button:hover { border-color:#444; }
    #label { color: var(--muted); font-size: 13px; margin-top: 6px; }
    .probs { display:flex; flex-direction:column; gap:10px; margin-top: 8px; }
    .row { display:grid; grid-template-columns: 120px 1fr auto; gap:10px; align-items:center; }
    .name { color:#d1d5db; font-weight:600; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .bar { background:#1f1f1f; height: 12px; border-radius: 999px; overflow:hidden; border:1px solid #2a2a2a; }
    .bar > div { height: 100%; width:0%; background: linear-gradient(90deg, #3b82f6, #22d3ee, #a78bfa); transition: width 120ms ease; }
    .pct { min-width:58px; text-align:right; color:#c9c9c9; font-variant-numeric: tabular-nums; }
    footer { text-align:center; color:#6b7280; padding: 10px 0 30px; font-size: 12px; }
    canvas, video { width:100%; border-radius: 12px; background:#000; }
    .hint { font-size: 12px; color:#9aa0a6; margin-top:8px; }
    @media (max-width: 860px) {
      main { grid-template-columns: 1fr; }
    }

    /* 업로더 */
    .uploader { margin-top: 8px; }
    #dropzone {
      border:1px dashed #2a2a2a; border-radius:12px; padding:16px;
      text-align:center; background:#0f0f0f;
    }
    #dropzone.dragover { border-color:#3b82f6; background:#121212; }
    .preview { margin-top:10px; }
    .preview img { max-width:100%; border-radius:12px; display:block; }
    .hidden { display:none; }
  </style>
</head>
<body>
  <header>
    <h1>Find Wally — Image Detection [CDSD x MEC]</h1>
  </header>

  <main>
    <!-- Webcam 카드 -->
    <section class="card">
      <div id="webcam-container"></div>
      <div class="controls">
        <button id="startBtn">Start Webcam</button>
        <button id="stopBtn" disabled>Stop Webcam</button>
        <button id="switchCamBtn">Switch Camera</button>
      </div>
      <div class="hint">Use HTTPS (or localhost) so the browser allows webcam access.</div>
    </section>

    <!-- 확률 표시 카드 -->
    <section class="card">
      <h2 style="margin:0 0 8px 0;font-size:16px;">Live Probabilities</h2>
      <div id="label">Waiting for webcam...</div>
      <div class="probs" id="probs"></div>
    </section>

    <!-- 업로드 / 드래그앤드롭 카드 -->
    <section class="card">
      <h2 style="margin:0 0 8px 0;font-size:16px;">Upload or Drag & Drop</h2>

      <div class="uploader">
        <div id="dropzone">
          <p style="margin:0;">Drop an image here, or</p>
          <button id="pickBtn" type="button" style="margin-top:8px;">Choose Image</button>
          <input id="fileInput" type="file" accept="image/*" style="display:none;" />
        </div>
        <div id="preview" class="preview hidden">
          <img id="previewImg" alt="preview" />
        </div>
      </div>

      <div class="hint">Drag & drop a photo (Wally / non-Wally). Uploading pauses the webcam loop; press “Start Webcam” to resume.</div>
    </section>
  </main>

  <footer>Powered by TensorFlow.js + Teachable Machine</footer>

  <!-- libs -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@0.8.4/dist/teachablemachine-image.min.js"></script>

  <script>
    // ====== Configs ======
    const MODEL_URL = "./model/"; // GitHub Pages에선 index.html과 같은 경로의 model/ 폴더 사용

    // ====== State ======
    let model, webcam, maxPredictions, labels = [];
    let animId = null;

    // 전면/후면 카메라 상태 (기본 전면)
    let facingMode = localStorage.getItem("facingMode") || "user"; // "user" | "environment"

    // 업로드 시 루프 일시정지 플래그
    let pausedForUpload = false;

    // ====== Elements ======
    const startBtn = document.getElementById("startBtn");
    const stopBtn = document.getElementById("stopBtn");
    const switchCamBtn = document.getElementById("switchCamBtn");
    const probsEl = document.getElementById("probs");
    const labelEl = document.getElementById("label");
    const fileInput = document.getElementById("fileInput");
    const pickBtn = document.getElementById("pickBtn");
    const dropzone = document.getElementById("dropzone");
    const preview = document.getElementById("preview");
    const previewImg = document.getElementById("previewImg");

    // ====== Model ======
    async function loadModel() {
      if (model) return;
      model = await tmImage.load(MODEL_URL + "model.json", MODEL_URL + "metadata.json");
      maxPredictions = model.getTotalClasses();
      labels = model.getClassLabels();
      renderRows(labels);
    }

    // ====== UI: Prob Rows ======
    function renderRows(names) {
      probsEl.innerHTML = "";
      for (const n of names) {
        const row = document.createElement("div");
        row.className = "row";
        row.innerHTML = `
          <div class="name">${n}</div>
          <div class="bar"><div></div></div>
          <div class="pct">0.00%</div>
        `;
        probsEl.appendChild(row);
      }
    }
    function setRow(idx, p) {
      const row = probsEl.children[idx];
      if (!row) return;
      const bar = row.querySelector(".bar > div");
      const pct = row.querySelector(".pct");
      const w = Math.round(p * 10000) / 100; // 0.00%
      bar.style.width = w + "%";
      pct.textContent = w.toFixed(2) + "%";
    }

    // ====== Webcam ======
    async function initWebcam() {
      await loadModel();

      // 기존 webcam 정리
      if (animId) cancelAnimationFrame(animId);
      animId = null;
      if (webcam) {
        try { webcam.stop(); } catch (e) {}
        webcam = null;
      }

      // 전면은 mirror(true), 후면은 mirror(false)로 사용자 경험 개선
      const flip = (facingMode === "user");

      webcam = new tmImage.Webcam(400, 300, flip);
      await webcam.setup({ facingMode }); // "user" = 전면, "environment" = 후면
      await webcam.play();

      const cont = document.getElementById("webcam-container");
      cont.innerHTML = "";
      cont.appendChild(webcam.canvas);

      startBtn.disabled = true;
      stopBtn.disabled = false;
      labelEl.textContent = "Predicting...";

      window.requestAnimationFrame(loop);
    }

    async function loop() {
      if (!webcam) return;
      webcam.update();
      await predict();
      animId = window.requestAnimationFrame(loop);
    }

    async function predict() {
      const prediction = await model.predict(webcam.canvas);
      prediction.forEach((p, i) => setRow(i, p.probability));

      const best = prediction.reduce((a, b) => (a.probability > b.probability ? a : b));
      labelEl.textContent = "Top: " + best.className + " (" + (best.probability*100).toFixed(2) + "%)";
    }

    function stopWebcam() {
      if (animId) cancelAnimationFrame(animId);
      animId = null;
      if (webcam) {
        try { webcam.stop(); } catch(e) {}
        webcam = null;
      }
      startBtn.disabled = false;
      stopBtn.disabled = true;
      labelEl.textContent = "Webcam stopped.";
    }

    // ====== Upload / Drag & Drop ======
    function pauseLoopIfRunning() {
      if (animId) {
        cancelAnimationFrame(animId);
        animId = null;
        pausedForUpload = true;
      }
    }
    function resumeLoopIfPaused() {
      if (pausedForUpload && webcam) {
        pausedForUpload = false;
        window.requestAnimationFrame(loop);
      }
    }

    pickBtn?.addEventListener("click", () => fileInput.click());
    fileInput?.addEventListener("change", async (e) => {
      const file = e.target.files?.[0];
      if (file) await handleImageFile(file);
    });

    ["dragenter","dragover"].forEach(evt =>
      dropzone?.addEventListener(evt, (e) => {
        e.preventDefault(); e.stopPropagation();
        dropzone.classList.add("dragover");
      })
    );
    ["dragleave","drop"].forEach(evt =>
      dropzone?.addEventListener(evt, (e) => {
        e.preventDefault(); e.stopPropagation();
        dropzone.classList.remove("dragover");
      })
    );
    dropzone?.addEventListener("drop", async (e) => {
      const file = e.dataTransfer.files?.[0];
      if (file) await handleImageFile(file);
    });

    async function handleImageFile(file) {
      try {
        await loadModel();
        pauseLoopIfRunning();

        const url = URL.createObjectURL(file);
        previewImg.src = url;
        preview.classList.remove("hidden");

        await new Promise((res, rej) => {
          previewImg.onload = res;
          previewImg.onerror = rej;
        });

        const preds = await model.predict(previewImg);
        preds.forEach((p, i) => setRow(i, p.probability));

        const best = preds.reduce((a, b) => (a.probability > b.probability ? a : b));
        labelEl.textContent = "Top (uploaded): " + best.className + " (" + (best.probability*100).toFixed(2) + "%)";
      } catch (err) {
        console.error(err);
        labelEl.textContent = "Upload failed. Try another image.";
      }
    }

    // ====== Events ======
    startBtn.addEventListener("click", async () => {
      await initWebcam();
      resumeLoopIfPaused();
    });
    stopBtn.addEventListener("click", stopWebcam);

    switchCamBtn?.addEventListener("click", async () => {
      await loadModel();
      facingMode = (facingMode === "user") ? "environment" : "user";
      localStorage.setItem("facingMode", facingMode);
      labelEl.textContent = `Switching to ${facingMode === "user" ? "Front" : "Back"} Camera...`;
      await initWebcam();
    });

    // 페이지 로드시 자동 초기화는 사용자가 Start 누르도록 두는 게 안전 (모바일 권한 팝업)
    // 필요하면 아래 주석 해제:
    // window.addEventListener("DOMContentLoaded", () => { /* no auto-start */ });
  </script>
</body>
</html>
