<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Find Wally — Image Detection [CDSD x MEC]</title>
  <style>
    :root { --bg:#0b0b0b; --fg:#eaeaea; --muted:#9aa0a6; --accent:#ff4d4f; }
    * { box-sizing: border-box; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; background:var(--bg); color:var(--fg); }
    header { padding: 24px 20px; border-bottom: 1px solid #222; display:flex; align-items:center; gap:12px; }
    header h1 { font-size: 18px; margin:0; font-weight:700; letter-spacing:0.3px; }
    main { max-width: 980px; margin: 24px auto; padding: 0 20px 60px; display:grid; grid-template-columns: 1fr 1fr; gap: 24px; }
    .card { background:#111; border:1px solid #222; border-radius: 16px; padding: 16px; box-shadow: 0 10px 24px rgba(0,0,0,0.25); }
    .controls { display:flex; gap:10px; margin-top:12px; flex-wrap:wrap; }
    button { padding:10px 14px; border-radius: 10px; border:1px solid #333; background:#181818; color:var(--fg); cursor:pointer; font-weight:600; }
    button:hover { border-color:#444; }
    #label { color: var(--muted); font-size: 13px; margin-top: 6px; }
    .probs { display:flex; flex-direction:column; gap:10px; margin-top: 8px; }
    .row { display:grid; grid-template-columns: 120px 1fr auto; gap:10px; align-items:center; }
    .name { color:#d1d5db; font-weight:600; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .bar { background:#1f1f1f; height: 12px; border-radius: 999px; overflow:hidden; border:1px solid #2a2a2a; }
    .bar > div { height: 100%; width:0%; background: linear-gradient(90deg, #3b82f6, #22d3ee, #a78bfa); transition: width 120ms ease; }
    .pct { min-width:58px; text-align:right; color:#c9c9c9; font-variant-numeric: tabular-nums; }
    footer { text-align:center; color:#6b7280; padding: 10px 0 30px; font-size: 12px; }
    canvas, video { width:100%; border-radius: 12px; background:#000; }
    .hint { font-size: 12px; color:#9aa0a6; margin-top:8px; }
    @media (max-width: 860px) {
      main { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <header>
    <h1>Find Wally — Image Detection [CDSD x MEC]</h1>
  </header>

  <main>
    <!-- Webcam 카드 -->
    <section class="card">
      <div id="webcam-container"></div>
      <div class="controls">
        <button id="startBtn">Start Camera</button>
        <button id="stopBtn" disabled>Stop Camera</button>
        <button id="switchCamBtn">Switch Camera</button>
      </div>
      <div class="hint">Use HTTPS (or localhost) so the browser allows webcam access.</div>
    </section>

    <!-- 확률 표시 카드 -->
    <section class="card">
      <h2 style="margin:0 0 8px 0;font-size:16px;">Live Probabilities</h2>
      <div id="label">Waiting for camera...</div>
      <div class="probs" id="probs"></div>
    </section>
  </main>

  <footer>Powered by TensorFlow.js + Teachable Machine</footer>

  <!-- libs -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@0.8.4/dist/teachablemachine-image.min.js"></script>

  <script>
    // ====== Config ======
    const MODEL_URL = "./model/"; // index.html과 같은 경로의 model/ 폴더

    // ====== State ======
    let model, webcam, maxPredictions, labels = [];
    let animId = null;
    let facingMode = localStorage.getItem("facingMode") || "user"; // "user" | "environment"

    // ====== Elements ======
    const startBtn = document.getElementById("startBtn");
    const stopBtn = document.getElementById("stopBtn");
    const switchCamBtn = document.getElementById("switchCamBtn");
    const probsEl = document.getElementById("probs");
    const labelEl = document.getElementById("label");

    // ====== Model ======
    async function loadModel() {
      if (model) return;
      model = await tmImage.load(MODEL_URL + "model.json", MODEL_URL + "metadata.json");
      maxPredictions = model.getTotalClasses();
      labels = model.getClassLabels();
      renderRows(labels);
    }

    // ====== UI: Prob Rows ======
    function renderRows(names) {
      probsEl.innerHTML = "";
      for (const n of names) {
        const row = document.createElement("div");
        row.className = "row";
        row.innerHTML = `
          <div class="name">${n}</div>
          <div class="bar"><div></div></div>
          <div class="pct">0.00%</div>
        `;
        probsEl.appendChild(row);
      }
    }
    function setRow(idx, p) {
      const row = probsEl.children[idx];
      if (!row) return;
      const bar = row.querySelector(".bar > div");
      const pct = row.querySelector(".pct");
      const w = Math.round(p * 10000) / 100; // 0.00%
      bar.style.width = w + "%";
      pct.textContent = w.toFixed(2) + "%";
    }

    // ====== (iOS 안정성) deviceId 백업 탐색 ======
    async function getDeviceIdForMode(target = "environment") {
      try { await navigator.mediaDevices.getUserMedia({ video: true }); } catch {}
      const devices = await navigator.mediaDevices.enumerateDevices();
      const cams = devices.filter(d => d.kind === "videoinput");
      const keywords = target === "environment"
        ? [/back/i, /rear/i, /environment/i]
        : [/front/i, /user/i, /face/i];
      const byLabel = cams.find(c => keywords.some(rx => rx.test(c.label)));
      return byLabel?.deviceId || cams[0]?.deviceId || null;
    }

    // ====== Webcam ======
    async function initWebcam() {
      await loadModel();

      // 기존 정리
      if (animId) cancelAnimationFrame(animId);
      animId = null;
      if (webcam) {
        try { webcam.stop(); } catch (e) {}
        webcam = null;
      }

      const flip = (facingMode === "user"); // 전면은 미러링
      webcam = new tmImage.Webcam(400, 300, flip);

      // 기본: facingMode로 시도, 실패하면 deviceId로 재시도
      try {
        await webcam.setup({ facingMode });
      } catch (e) {
        const id = await getDeviceIdForMode(facingMode);
        if (!id) throw e;
        await webcam.setup({ deviceId: { exact: id } });
      }

      await webcam.play();

      const cont = document.getElementById("webcam-container");
      cont.innerHTML = "";
      cont.appendChild(webcam.canvas);

      startBtn.disabled = true;
      stopBtn.disabled = false;
      labelEl.textContent = "Predicting...";

      window.requestAnimationFrame(loop);
    }

    async function loop() {
      if (!webcam) return;
      webcam.update();
      await predict();
      animId = window.requestAnimationFrame(loop);
    }

    async function predict() {
      const prediction = await model.predict(webcam.canvas);
      prediction.forEach((p, i) => setRow(i, p.probability));

      const best = prediction.reduce((a, b) => (a.probability > b.probability ? a : b));
      labelEl.textContent = "Top: " + best.className + " (" + (best.probability*100).toFixed(2) + "%)";
    }

    function stopWebcam() {
      if (animId) cancelAnimationFrame(animId);
      animId = null;
      if (webcam) {
        try { webcam.stop(); } catch(e) {}
        webcam = null;
      }
      startBtn.disabled = false;
      stopBtn.disabled = true;
      labelEl.textContent = "Camera stopped.";
    }

    // ====== Events ======
    startBtn.addEventListener("click", initWebcam);
    stopBtn.addEventListener("click", stopWebcam);

    switchCamBtn?.addEventListener("click", async () => {
      await loadModel();
      facingMode = (facingMode === "user") ? "environment" : "user";
      localStorage.setItem("facingMode", facingMode);
      labelEl.textContent = `Switching to ${facingMode === "user" ? "Front" : "Back"} Camera...`;
      await initWebcam();
    });
  </script>
</body>
</html>
