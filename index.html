<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Find Wally with AI - [CDSD x MEC]</title>
  <style>
    :root{
      --bg:#0b0b0b; --fg:#eaeaea; --muted:#9aa0a6; --accent:#ff4d4f;
      --card:#111; --border:#222;
      --safe-bottom: env(safe-area-inset-bottom, 0px);
      --safe-top: env(safe-area-inset-top, 0px);
    }
    *{ box-sizing:border-box; -webkit-tap-highlight-color: transparent; }
    html,body{ margin:0; height:100%; background:var(--bg); color:var(--fg); font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; }

    /* ===== Header ===== */
    header{
      position:sticky; top:0; z-index:5;
      display:flex; align-items:center; gap:10px;
      padding: calc(10px + var(--safe-top)) 16px 12px;
      background:rgba(11,11,11,.9);
      backdrop-filter:saturate(120%) blur(6px);
      border-bottom:1px solid var(--border);
    }
    header img{ width:40px; height:40px; border-radius:8px; object-fit:cover; }
    header h1{ margin:0; font-size:17px; font-weight:800; letter-spacing:.2px; }

    /* ===== Layout ===== */
    main{ padding: 10px 12px 120px; } /* 아래 컨트롤 & 줌 슬라이더 높이 고려 여백 */
    .card{ background:var(--card); border:1px solid var(--border); border-radius:16px; padding:12px; box-shadow:0 8px 24px rgba(0,0,0,.25); }
    .stack{ display:flex; flex-direction:column; gap:12px; }

    /* ===== Camera ===== */
    .cameraWrap{ position:relative; }
    .cameraHint{
      position:absolute; left:12px; top:12px;
      background:rgba(0,0,0,.55);
      padding:6px 10px; border-radius:999px;
      font-size:12px; color:#e5e7eb; border:1px solid #000;
      display:none; /* 카메라 켜진 뒤에만 보이게 */
    }
    canvas{
      width:100%;
      aspect-ratio: 1 / 1;   /* 정사각형 비율 */
      border-radius:14px;
      background:#000;
      max-height: 75dvh;
    }

    /* ===== Status / Prob ===== */
    .statusLine{ display:flex; justify-content:space-between; align-items:center; gap:8px; }
    .label{ color:var(--muted); font-size:13px; }
    .topBadge{ font-weight:800; font-size:14px; padding:6px 10px; border-radius:999px; border:1px solid #333; background:#151515; }
    .probs{ display:flex; flex-direction:column; gap:8px; }
    .row{ display:grid; grid-template-columns: 120px 1fr auto; gap:8px; align-items:center; }
    .name{ color:#d1d5db; font-weight:700; font-size:13px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .bar{ background:#1f1f1f; height:12px; border-radius:999px; overflow:hidden; border:1px solid #2a2a2a; }
    .bar>div{ height:100%; width:0%; background: linear-gradient(90deg,#3b82f6,#22d3ee,#a78bfa); transition: width 120ms ease; }
    .pct{ min-width:58px; text-align:right; color:#c9c9c9; font-variant-numeric: tabular-nums; font-size:13px; }

    /* ===== Controls ===== */
    .controls{
      position:fixed; left:0; right:0; bottom:0; z-index:10;
      background:rgba(15,15,15,.92); backdrop-filter:saturate(120%) blur(8px);
      border-top:1px solid var(--border);
      padding:10px 12px calc(10px + var(--safe-bottom));
    }
    .controlsInner{ display:grid; grid-template-columns: 1fr 1fr 1fr; gap:8px; }
    button{
      appearance:none; border:1px solid #333; background:#181818; color:var(--fg);
      border-radius:12px; padding:14px 12px; font-weight:800; font-size:16px; cursor:pointer;
    }
    button:active{ transform:translateY(1px); }
    button[disabled]{ opacity:.5; pointer-events:none; }
    .accent{ background:#202020; border-color:#383838; }
    .danger{ background:#1e1e1e; border-color:#3a3a3a; }
    .switch{ background:#141414; border-color:#333; }

    /* ===== Zoom Slider ===== */
    .zoomWrap{
      margin-top:8px;
      display:none; /* 지원 기기에서 카메라 켜지면 표시 */
      align-items:center; gap:10px;
    }
    .zoomWrap .zoomLabel{ font-size:12px; color:#bdbdbd; min-width:40px; }
    .zoomWrap .zoomValue{ font-size:12px; color:#d1d5db; width:52px; text-align:right; font-variant-numeric: tabular-nums; }
    .zoomWrap input[type="range"]{
      -webkit-appearance:none; appearance:none;
      width:100%; height:30px; background:transparent;
    }
    .zoomWrap input[type="range"]::-webkit-slider-runnable-track{
      height:6px; background:#2a2a2a; border-radius:999px;
    }
    .zoomWrap input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance:none; appearance:none;
      width:18px; height:18px; border-radius:50%; background:#eaeaea; margin-top:-6px; border:1px solid #111;
    }
    .zoomWrap input[type="range"]::-moz-range-track{
      height:6px; background:#2a2a2a; border-radius:999px;
    }
    .zoomWrap input[type="range"]::-moz-range-thumb{
      width:18px; height:18px; border-radius:50%; background:#eaeaea; border:1px solid #111;
    }

    .highlight{ outline:2px solid var(--accent); box-shadow:0 0 0 4px rgba(255,77,79,.25); transition: box-shadow 200ms ease; }
    footer{ text-align:center; color:#6b7280; padding:8px 0 12px; font-size:11px; }

    @media(min-width:900px){
      main{ max-width:980px; margin:0 auto; }
      .stack{ flex-direction:row; }
      .stack>.card{ flex:1; }
      canvas{ aspect-ratio: 1 / 1; max-height: 65dvh; }
    }
  </style>
</head>
<body>
  <header>
    <img src="cdsd_logo.png" alt="CDSD Logo" />
    <h1>Find Wally with AI - [CDSD x MEC]</h1>
  </header>

  <main>
    <div class="stack">
      <!-- 카메라 카드 -->
      <section class="card cameraWrap">
        <div class="cameraHint" id="cameraHint">Tip: Fill the frame with only WALLY</div>
        <div id="webcam-container"></div>
        <div class="statusLine" style="margin-top:10px;">
          <div class="label" id="label">Waiting for camera...</div>
          <div class="topBadge" id="topBadge">Top: —</div>
        </div>
      </section>

      <!-- 확률 카드 -->
      <section class="card">
        <h2 style="margin:0 0 10px 0; font-size:15px;">Live Probabilities</h2>
        <div class="probs" id="probs"></div>
      </section>
    </div>
  </main>

  <!-- 하단 고정 컨트롤 -->
  <div class="controls">
    <div class="controlsInner">
      <button id="startBtn" class="accent">Start</button>
      <button id="stopBtn" class="danger" disabled>Stop</button>
      <button id="switchCamBtn" class="switch">Switch</button>
    </div>

    <!-- Zoom slider (지원 기기에서만 표시) -->
    <div id="zoomWrap" class="zoomWrap">
      <span class="zoomLabel">Zoom</span>
      <input id="zoom" type="range" min="1" max="1" step="0.1" value="1" />
      <span class="zoomValue" id="zoomVal">1.0×</span>
    </div>

    <div class="label" style="margin-top:6px;">NOTICE: If you allowed camera access, please tap the "Start" button again.</div>
  </div>

  <footer>Powered by TensorFlow.js + Teachable Machine</footer>

  <!-- libs -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@0.8.4/dist/teachablemachine-image.min.js"></script>

  <script>
    // ===== Config =====
    const MODEL_URL = "./model/";
    const SUCCESS_THRESHOLD = 0.8; // 80%

    // ===== State =====
    let model, webcam, maxPredictions, labels = [];
    let animId = null;
    let facingMode = localStorage.getItem("facingMode") || "user"; // "user" | "environment"
    let wakeLock = null;
    let currentTrack = null; // 현재 비디오 트랙(줌 제어용)

    // ===== Elements =====
    const startBtn = document.getElementById("startBtn");
    const stopBtn = document.getElementById("stopBtn");
    const switchCamBtn = document.getElementById("switchCamBtn");
    const probsEl = document.getElementById("probs");
    const labelEl = document.getElementById("label");
    const topBadgeEl = document.getElementById("topBadge");
    const cameraHintEl = document.getElementById("cameraHint");
    const zoomWrapEl = document.getElementById("zoomWrap");
    const zoomEl = document.getElementById("zoom");
    const zoomValEl = document.getElementById("zoomVal");

    // ===== Model =====
    async function loadModel(){
      if(model) return;
      model = await tmImage.load(MODEL_URL + "model.json", MODEL_URL + "metadata.json");
      maxPredictions = model.getTotalClasses();
      labels = model.getClassLabels();
      renderRows(labels);
    }

    // ===== UI: Prob Rows =====
    function renderRows(names){
      probsEl.innerHTML = "";
      for(const n of names){
        const row = document.createElement("div");
        row.className = "row";
        row.innerHTML = `
          <div class="name">${n}</div>
          <div class="bar"><div></div></div>
          <div class="pct">0.00%</div>`;
        probsEl.appendChild(row);
      }
    }
    function setRow(idx, p){
      const row = probsEl.children[idx];
      if(!row) return;
      const bar = row.querySelector(".bar > div");
      const pct = row.querySelector(".pct");
      const w = Math.round(p * 10000) / 100;
      bar.style.width = w + "%";
      pct.textContent = w.toFixed(2) + "%";
    }

    // ===== Helpers =====
    function vibrateOk(){ if("vibrate" in navigator) navigator.vibrate?.(30); }
    async function requestWakeLock(){
      try{
        if("wakeLock" in navigator){
          wakeLock = await navigator.wakeLock.request("screen");
          wakeLock.addEventListener?.("release", ()=>{ wakeLock = null; });
        }
      }catch(e){}
    }
    async function getDeviceIdForMode(target="environment"){
      try{ await navigator.mediaDevices.getUserMedia({ video:true }); }catch{}
      const devices = await navigator.mediaDevices.enumerateDevices();
      const cams = devices.filter(d => d.kind === "videoinput");
      const keywords = target === "environment" ? [/back/i,/rear/i,/environment/i] : [/front/i,/user/i,/face/i];
      const byLabel = cams.find(c => keywords.some(rx => rx.test(c.label)));
      return byLabel?.deviceId || cams[0]?.deviceId || null;
    }

    // ===== Zoom Setup / Control =====
    function hideZoom(){
      zoomWrapEl.style.display = "none";
      zoomEl.value = "1";
      zoomValEl.textContent = "1.0×";
    }

    function setupZoom(track){
      try{
        const caps = track.getCapabilities?.();
        if (!caps || !caps.zoom){
          hideZoom(); // 지원 안하면 숨김
          return;
        }
        const settings = track.getSettings?.() || {};
        const min = caps.zoom.min ?? 1;
        const max = caps.zoom.max ?? Math.max(1.0, (settings.zoom || 1) + 1);
        const step = caps.zoom.step ?? 0.1;
        const val = settings.zoom ?? min;

        zoomEl.min = String(min);
        zoomEl.max = String(max);
        zoomEl.step = String(step);
        zoomEl.value = String(val);
        zoomValEl.textContent = `${Number(zoomEl.value).toFixed(1)}×`;
        zoomWrapEl.style.display = "flex";

        zoomEl.oninput = async () => {
          const z = parseFloat(zoomEl.value);
          zoomValEl.textContent = `${z.toFixed(1)}×`;
          try{
            await track.applyConstraints({ advanced: [{ zoom: z }] });
          }catch(e){
            // 일부 기기에서 중간값 안 먹을 수 있음
          }
        };
      }catch(e){
        hideZoom();
      }
    }

    // ===== Webcam =====
    async function initWebcam(){
      await loadModel();

      if (animId) cancelAnimationFrame(animId);
      animId = null;
      if (webcam) { try { webcam.stop(); } catch(e){} webcam = null; }
      currentTrack = null;
      hideZoom();

      const flip = (facingMode === "user");
      webcam = new tmImage.Webcam(480, 480, flip); // 내부 캔버스 정사각형

      // facingMode 우선, 실패 시 deviceId 백업
      try{
        await webcam.setup({ facingMode });
      }catch(e){
        const id = await getDeviceIdForMode(facingMode);
        if (!id) throw e;
        await webcam.setup({ deviceId: { exact: id } });
      }

      await webcam.play();

      // 내부 비디오 트랙 확보하여 줌 구성
      try{
        const video = webcam.webcam; // tmImage.Webcam 내부의 <video>
        const stream = video?.srcObject;
        currentTrack = stream?.getVideoTracks?.()[0] || null;
        if (currentTrack) setupZoom(currentTrack);
      }catch(e){
        // 트랙 접근 실패 시 줌 감춤
        hideZoom();
      }

      const cont = document.getElementById("webcam-container");
      cont.innerHTML = "";
      cont.appendChild(webcam.canvas);

      // 카메라가 실제로 켜진 뒤 Tip 표시
      cameraHintEl.style.display = "block";

      startBtn.disabled = true;
      stopBtn.disabled = false;
      labelEl.textContent = "Predicting...";
      await requestWakeLock();
      window.requestAnimationFrame(loop);
    }

    async function loop(){
      if(!webcam) return;
      webcam.update();
      await predict();
      animId = window.requestAnimationFrame(loop);
    }

    async function predict(){
      const prediction = await model.predict(webcam.canvas);
      prediction.forEach((p,i)=> setRow(i, p.probability));

      const best = prediction.reduce((a,b)=> (a.probability > b.probability ? a : b));
      topBadgeEl.textContent = `Top: ${best.className} ${(best.probability*100).toFixed(1)}%`;

      const isHit = best.probability >= SUCCESS_THRESHOLD;
      webcam.canvas.classList.toggle("highlight", isHit);
      if(isHit) vibrateOk();
    }

    function stopWebcam(){
      if (animId) cancelAnimationFrame(animId);
      animId = null;
      if (webcam) { try { webcam.stop(); } catch(e){} webcam = null; }
      if (wakeLock){ try{ wakeLock.release(); }catch(e){} wakeLock = null; }

      startBtn.disabled = false;
      stopBtn.disabled = true;
      labelEl.textContent = "Camera stopped.";
      topBadgeEl.textContent = "Top: —";
      cameraHintEl.style.display = "none";
      hideZoom();

      const cont = document.getElementById("webcam-container");
      cont.querySelector("canvas")?.classList.remove("highlight");
    }

    // ===== Events =====
    startBtn.addEventListener("click", initWebcam);
    stopBtn.addEventListener("click", stopWebcam);
    switchCamBtn.addEventListener("click", async ()=>{
      await loadModel();
      facingMode = (facingMode === "user") ? "environment" : "user";
      localStorage.setItem("facingMode", facingMode);
      labelEl.textContent = `Switching to ${facingMode === "user" ? "Front" : "Back"} Camera...`;
      await initWebcam();
    });

    // iOS에서 탭 복귀 시 루프/웨이크락 복구
    document.addEventListener("visibilitychange", ()=>{
      if (document.visibilityState === "visible" && webcam && !animId) {
        window.requestAnimationFrame(loop);
      }
      if (document.visibilityState === "visible" && webcam && !wakeLock) {
        requestWakeLock();
      }
    });
  </script>
</body>
</html>
